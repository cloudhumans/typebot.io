name: Typebot CI

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_BUILDER_REPOSITORY: typebot-builder
  ECR_VIEWER_REPOSITORY: typebot-viewer
  ECR_REGISTRY: 585814034319.dkr.ecr.us-east-1.amazonaws.com
  SSM_PARAM_NAME: '/prd/typebot/databases'

jobs:
  prepare-matrix:
    name: Prepare migration matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.build-matrix.outputs.matrix }}
      count: ${{ steps.build-matrix.outputs.count }}
    steps:
      - name: Configure AWS credentials production
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_CI_EKS_PRODUCTION_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_CI_EKS_PRODUCTION_SECRET }}
          aws-region: us-east-1

      - name: Fetch SSM parameter & build matrix (names only, no jq)
        id: build-matrix
        run: |
          set -euo pipefail
          echo "Reading SSM parameter: $SSM_PARAM_NAME"
          RAW=$(aws ssm get-parameter --name "$SSM_PARAM_NAME" --with-decryption --query 'Parameter.Value' --output text || true)
          if [ -z "$RAW" ]; then
            echo "No content in parameter" >&2
            echo 'matrix={"include":[]}' >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "Building matrix (pure bash)..."
          items=""
          count=0
          while IFS= read -r line; do
            [ -z "$line" ] && continue
            case "$line" in \#*) continue;; esac
            case "$line" in *=*) : ;; *) continue;; esac
            name=${line%%=*}
            [ -z "$name" ] && continue
            safe_name=$(printf '%s' "$name" | tr -cd '[:alnum:]_-')
            [ -z "$safe_name" ] && continue
            case ",$items," in *",{\"name\":\"$safe_name\"},"*) continue;; esac
            if [ -n "$items" ]; then
              items="$items,{\"name\":\"$safe_name\"}"
            else
              items="{\"name\":\"$safe_name\"}"
            fi
            count=$((count+1))
          done <<< "$RAW"
          MATRIX='{"include":['"$items"']}'
          echo "Matrix count: $count" >&2
          if [ "$count" -gt 0 ]; then
            echo "Instances included (names only):" >&2
            printf '%s' "$items" | sed -n 's/.*"name":"\([^"]*\)".*/ - \1/p'
          fi
          echo "matrix=$MATRIX" >> "$GITHUB_OUTPUT"
          echo "count=$count" >> "$GITHUB_OUTPUT"

  migrate:
    name: Migrate (per instance)
    if: ${{ needs.prepare-matrix.outputs.count != '0' }}
    needs: prepare-matrix
    strategy:
      fail-fast: false
      max-parallel: 3
      matrix: ${{ fromJson(needs.prepare-matrix.outputs.matrix) }}
    runs-on: [self-hosted, production]
    steps:
      - name: Configure AWS credentials production
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_CI_EKS_PRODUCTION_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_CI_EKS_PRODUCTION_SECRET }}
          aws-region: us-east-1

      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 8.15.4
          run_install: false

      - name: Install dependencies (prisma only)
        run: |
          set -euo pipefail
          pnpm install --frozen-lockfile --filter @typebot.io/prisma... || pnpm install --frozen-lockfile

      - name: Prepare connection
        id: prepare-connection
        env:
          INSTANCE_NAME: ${{ matrix.name }}
        run: |
          set -euo pipefail
          if [ -z "${INSTANCE_NAME:-}" ]; then
            echo "Missing INSTANCE_NAME" >&2; exit 1; fi
          RAW=$(aws ssm get-parameter --name "$SSM_PARAM_NAME" --with-decryption --query 'Parameter.Value' --output text)
          LINE=$(printf '%s\n' "$RAW" | grep -E "^${INSTANCE_NAME}=") || { echo "Instance $INSTANCE_NAME not found" >&2; exit 1; }
          CONNECTION=${LINE#*=}
          if [ -z "$CONNECTION" ]; then
            echo "Empty connection string for $INSTANCE_NAME" >&2; exit 1; fi
          case "$CONNECTION" in
            postgresql://*|postgres://*) : ;;
            *) echo "Invalid protocol for $INSTANCE_NAME" >&2; exit 1;;
          esac
          echo "::add-mask::$CONNECTION"
          echo "Prepared connection for $INSTANCE_NAME"
          # Set as step output
          echo "connection=$CONNECTION" >> "$GITHUB_OUTPUT"

      - name: Test connection
        env:
          INSTANCE_NAME: ${{ matrix.name }}
          CONNECTION: ${{ steps.prepare-connection.outputs.connection }}
        run: |
          set -euo pipefail
          if [ -z "${CONNECTION:-}" ]; then
            echo "Missing CONNECTION variable for $INSTANCE_NAME" >&2; exit 1; fi
          IMAGE=postgres:17-alpine
          echo "Pulling $IMAGE for test..."
          docker pull "$IMAGE" >/dev/null
          echo "Testing connection for $INSTANCE_NAME"
          docker run --rm "$IMAGE" sh -c "PGCONNECT_TIMEOUT=5 psql '$CONNECTION' -v ON_ERROR_STOP=1 -c 'SELECT 1;'" >/dev/null
          echo "Connection OK for $INSTANCE_NAME"

      - name: Run migration
        if: ${{ github.ref == 'refs/heads/main' }}
        env:
          INSTANCE_NAME: ${{ matrix.name }}
          CONNECTION: ${{ steps.prepare-connection.outputs.connection }}
        run: |
          set -euo pipefail
          if [ -z "${CONNECTION:-}" ]; then
            echo "Missing CONNECTION variable for $INSTANCE_NAME" >&2; exit 1; fi
          echo "Running migration for instance: $INSTANCE_NAME"
          # Use the package script which auto-selects the correct schema based on DATABASE_URL
          DATABASE_URL="$CONNECTION" pnpm --filter @typebot.io/prisma run migrate:deploy
          echo "Migration done for $INSTANCE_NAME"

  build:
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    needs: migrate
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Configure AWS credentials production
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_CI_EKS_PRODUCTION_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_CI_EKS_PRODUCTION_SECRET }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Compute version
        uses: cloudhumans/actions/app-version@v1
        with:
          version_file: version
          format: '{base}-{sha7}'

      - name: Build, tag, and push BUILDER image to Amazon ECR
        if: ${{ github.ref == 'refs/heads/main' }}
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_BUILDER_REPOSITORY:$IMAGE_TAG --build-arg SCOPE=builder .
          docker push $ECR_REGISTRY/$ECR_BUILDER_REPOSITORY:$IMAGE_TAG

      - name: Build, tag, and push VIEWER image to Amazon ECR
        if: ${{ github.ref == 'refs/heads/main' }}
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_VIEWER_REPOSITORY:$IMAGE_TAG --build-arg SCOPE=viewer .
          docker push $ECR_REGISTRY/$ECR_VIEWER_REPOSITORY:$IMAGE_TAG

      - name: install kubectl and kustomize
        if: ${{ github.ref == 'refs/heads/main' }}
        run: |
          curl -sfLo kustomize.tar.gz https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize%2Fv4.1.1/kustomize_v4.1.1_linux_amd64.tar.gz && tar -xvf kustomize.tar.gz && chmod u+x kustomize
          curl -LO "https://dl.k8s.io/release/v1.23.6/bin/linux/amd64/kubectl" && chmod u+x kubectl

      - name: export common variables
        run: |
          echo "KUSTOMIZE_CMD=$PWD/kustomize" >> $GITHUB_ENV
          echo "KUBECTL_CMD=$PWD/kubectl" >> $GITHUB_ENV

      - name: Deploy in production
        if: ${{ github.ref == 'refs/heads/main' }}
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          pushd deploy/base
          $KUSTOMIZE_CMD edit set image typebot-builder-image="$ECR_REGISTRY/$ECR_BUILDER_REPOSITORY:$IMAGE_TAG"
          $KUSTOMIZE_CMD edit set image typebot-viewer-image="$ECR_REGISTRY/$ECR_VIEWER_REPOSITORY:$IMAGE_TAG"
          popd
          aws eks --region us-east-1 update-kubeconfig --name kubernetes-production
          $KUSTOMIZE_CMD build deploy/overlays/prd
          $KUSTOMIZE_CMD build deploy/overlays/prd | $KUBECTL_CMD apply -f -

      - name: Deploy instace2 in production
        if: ${{ github.ref == 'refs/heads/main' }}
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          pushd deploy/base
          $KUSTOMIZE_CMD edit set image typebot-builder-image="$ECR_REGISTRY/$ECR_BUILDER_REPOSITORY:$IMAGE_TAG"
          $KUSTOMIZE_CMD edit set image typebot-viewer-image="$ECR_REGISTRY/$ECR_VIEWER_REPOSITORY:$IMAGE_TAG"
          popd
          aws eks --region us-east-1 update-kubeconfig --name kubernetes-production
          $KUSTOMIZE_CMD build deploy/overlays/prd-instance2
          $KUSTOMIZE_CMD build deploy/overlays/prd-instance2 | $KUBECTL_CMD apply -f -

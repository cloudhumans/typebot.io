---
phase: 01-logger-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - packages/lib/logger.test.ts
autonomous: true
requirements:
  - LOG-01
  - LOG-02
  - LOG-04

must_haves:
  truths:
    - "A Vitest unit test proves the logger emits single-line JSON to stdout when DD_LOGS_ENABLED=true"
    - "The test asserts ddsource and service are present as top-level fields in every log entry"
    - "The test asserts nested metadata objects serialize as nested JSON keys, not flattened strings"
    - "The test passes when run via npx vitest run packages/lib/logger.test.ts"
  artifacts:
    - path: "packages/lib/logger.test.ts"
      provides: "Unit test for logger JSON output, static fields, and nested serialization"
      min_lines: 40
  key_links:
    - from: "packages/lib/logger.test.ts"
      to: "packages/lib/logger.ts"
      via: "Spawns a child process with DD_LOGS_ENABLED=true NODE_ENV=production that requires logger and captures stdout"
      pattern: "child_process|execSync|spawn"
---

<objective>
Create a Vitest unit test that verifies the Winston logger emits correct JSON output: single-line JSON with ddsource, service, and nested metadata objects serialized as nested JSON keys.

Purpose: LOG-04 (nested metadata serialization) requires a test to prove that `logger.info('msg', { workflow: { id: 'x' } })` produces `"workflow":{"id":"x"}` in stdout JSON, not a flattened or stringified form. This test also serves as the automated verification for LOG-01 and LOG-02.

Output: packages/lib/logger.test.ts with passing tests covering JSON format, static fields, and nested serialization.
</objective>

<execution_context>
@/home/giordanowt/.claude/get-shit-done/workflows/execute-plan.md
@/home/giordanowt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-logger-foundation/01-RESEARCH.md
@.planning/phases/01-logger-foundation/01-01-SUMMARY.md
@packages/lib/logger.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create logger unit test for JSON output, static fields, and nested serialization</name>
  <files>packages/lib/logger.test.ts</files>
  <action>
Create `packages/lib/logger.test.ts` using Vitest. The test must spawn a child process (because the logger is a singleton that reads env vars at module load time and redirects console -- it cannot be re-initialized within the same process).

Use `execSync` from `child_process` to run a small Node.js script that:
1. Sets `DD_LOGS_ENABLED=true` and `NODE_ENV=production` as environment variables
2. Requires `./packages/lib/logger` and calls `logger.default.info(...)` with test data
3. Captures stdout and parses the JSON

Test structure following project conventions (Vitest, no semicolons, single quotes):

```typescript
import { describe, it, expect } from 'vitest'
import { execSync } from 'child_process'
import path from 'path'

const projectRoot = path.resolve(__dirname, '../..')

/**
 * Helper: runs a logger script in a child process with DD_LOGS_ENABLED=true
 * and returns the parsed JSON from stdout.
 */
const runLoggerScript = (loggerCall: string): Record<string, unknown> => {
  const script = `
    const logger = require('./packages/lib/logger').default;
    ${loggerCall}
  `
  const stdout = execSync(`node -e "${script.replace(/"/g, '\\"')}"`, {
    cwd: projectRoot,
    env: {
      ...process.env,
      DD_LOGS_ENABLED: 'true',
      NODE_ENV: 'production',
    },
    encoding: 'utf8',
  }).trim()

  // Take only the first line (the log entry)
  const firstLine = stdout.split('\n')[0]
  return JSON.parse(firstLine)
}

describe('logger (production JSON mode)', () => {
  it('should emit valid single-line JSON to stdout (LOG-01)', () => {
    const result = runLoggerScript("logger.info('test message');")
    expect(result).toBeDefined()
    expect(typeof result).toBe('object')
    expect(result.message).toBe('test message')
    expect(result.level).toBe('info')
  })

  it('should include ddsource and service as top-level fields (LOG-02)', () => {
    const result = runLoggerScript("logger.info('static fields test');")
    expect(result.ddsource).toBe('nodejs')
    expect(result.service).toBe('typebot-runner')
  })

  it('should serialize nested metadata as nested JSON keys, not flattened (LOG-04)', () => {
    const result = runLoggerScript(
      "logger.info('nested test', { workflow: { id: 'wf-123', version: '6', execution_id: 'sess-abc' }, typebot_block: { id: 'block-1', type: 'WebhookBlock' } });"
    )
    // Verify workflow is a nested object, not a flat string
    expect(result.workflow).toEqual({
      id: 'wf-123',
      version: '6',
      execution_id: 'sess-abc',
    })
    // Verify typebot_block is a nested object
    expect(result.typebot_block).toEqual({
      id: 'block-1',
      type: 'WebhookBlock',
    })
  })

  it('should include timestamp field in every log entry', () => {
    const result = runLoggerScript("logger.info('timestamp test');")
    expect(result.timestamp).toBeDefined()
    expect(typeof result.timestamp).toBe('string')
  })

  it('should respect DD_SERVICE env var override', () => {
    // This test uses a modified env to verify DD_SERVICE override
    const script = "const logger = require('./packages/lib/logger').default; logger.info('service override test');"
    const stdout = execSync(`node -e "${script.replace(/"/g, '\\"')}"`, {
      cwd: projectRoot,
      env: {
        ...process.env,
        DD_LOGS_ENABLED: 'true',
        NODE_ENV: 'production',
        DD_SERVICE: 'custom-service',
      },
      encoding: 'utf8',
    }).trim()
    const firstLine = stdout.split('\n')[0]
    const result = JSON.parse(firstLine)
    expect(result.service).toBe('custom-service')
  })
})
```

Key constraints:
- Follow project conventions: Vitest imports, no semicolons, single quotes (per .prettierrc: trailingComma es5, tabWidth 2, semi false, singleQuote true).
- Use `execSync` to spawn a child process -- the Winston logger singleton cannot be re-initialized in-process because it captures console at module load time.
- Set `cwd` to project root so `require('./packages/lib/logger')` works.
- Parse only the first line of stdout (the log entry) -- subsequent lines may contain other output.
- Test both the default `typebot-runner` service and the `DD_SERVICE` override.
- Do NOT mock Winston or the logger -- these tests verify real behavior by capturing actual stdout.
- The tests must work with the existing `packages/lib/logger.ts` structure (CommonJS require via `typeof window === 'undefined'` gate).
  </action>
  <verify>
    <automated>cd /home/giordanowt/Repositories/typebot.io && npx vitest run packages/lib/logger.test.ts --reporter=verbose 2>&1 | tail -20</automated>
    <manual>All 5 tests pass: JSON output, ddsource/service fields, nested serialization, timestamp, DD_SERVICE override</manual>
  </verify>
  <done>packages/lib/logger.test.ts exists with 5 passing tests covering LOG-01 (single-line JSON), LOG-02 (ddsource + service), LOG-04 (nested metadata serialization), timestamp presence, and DD_SERVICE override.</done>
</task>

<task type="auto">
  <name>Task 2: Verify env schema validation rejects invalid DD_LOGS_ENABLED</name>
  <files>packages/lib/logger.test.ts</files>
  <action>
Add one more test case to the existing `packages/lib/logger.test.ts` file that verifies LOG-03 indirectly. Since the Zod validation runs when `@typebot.io/env` is imported (not when the logger is imported), this test verifies the env module behavior directly.

Add to the describe block:

```typescript
describe('env schema validation (LOG-03)', () => {
  it('should reject invalid DD_LOGS_ENABLED value', () => {
    // Verify the Zod schema rejects invalid values by importing env.ts
    // with SKIP_ENV_CHECK=false and DD_LOGS_ENABLED=invalid
    // This must throw during module import
    const script = "require('./packages/env/env.ts');"
    expect(() => {
      execSync(`node -e "${script.replace(/"/g, '\\"')}"`, {
        cwd: projectRoot,
        env: {
          ...process.env,
          DD_LOGS_ENABLED: 'invalid',
          SKIP_ENV_CHECK: 'false',
          NODE_ENV: 'production',
        },
        encoding: 'utf8',
        stdio: 'pipe',
      })
    }).toThrow()
  })
})
```

However, note that `packages/env/env.ts` is a TypeScript file using ESM imports -- it cannot be `require()`'d directly. The env validation actually happens when a compiled Next.js app imports it. Instead, take a simpler approach: verify the Zod schema shape by checking the file content programmatically (already done in Plan 01 Task 1 verify), and document in a comment that the full integration test (app startup with invalid DD_LOGS_ENABLED) should be run manually:

```typescript
// LOG-03 integration note: Full startup-failure verification requires running
// the compiled Next.js app with DD_LOGS_ENABLED=invalid and SKIP_ENV_CHECK=false.
// The Zod schema addition is verified by Plan 01 Task 1's automated check.
// Manual test: DD_LOGS_ENABLED=invalid pnpm --filter @typebot.io/viewer dev
// Expected: startup throws "Invalid environment variables: {\"DD_LOGS_ENABLED\":...}"
```

Add this as a comment block inside the test file, after the main describe block. This documents the verification path for LOG-03 without creating a flaky test that depends on the full Next.js compilation pipeline.
  </action>
  <verify>
    <automated>cd /home/giordanowt/Repositories/typebot.io && npx vitest run packages/lib/logger.test.ts --reporter=verbose 2>&1 | tail -20</automated>
    <manual>All tests still pass. LOG-03 verification note is documented in the test file as a comment.</manual>
  </verify>
  <done>packages/lib/logger.test.ts includes all automated tests passing plus a documented LOG-03 manual verification path. The test file is complete and covers LOG-01, LOG-02, LOG-04 via automated tests and LOG-03 via documented manual verification.</done>
</task>

</tasks>

<verification>
Run the full test suite for this file:

```bash
cd /home/giordanowt/Repositories/typebot.io && npx vitest run packages/lib/logger.test.ts --reporter=verbose
```

Expected: All tests pass. Specifically:
- LOG-01: JSON output test passes (valid single-line JSON)
- LOG-02: Static fields test passes (ddsource: nodejs, service: typebot-runner)
- LOG-04: Nested serialization test passes (workflow and typebot_block are nested objects, not flat)
</verification>

<success_criteria>
1. packages/lib/logger.test.ts exists with at least 5 test cases
2. All tests pass when run via `npx vitest run packages/lib/logger.test.ts`
3. Tests cover: JSON format (LOG-01), static fields (LOG-02), nested serialization (LOG-04)
4. DD_SERVICE override test confirms the env var is respected
5. LOG-03 verification path is documented
</success_criteria>

<output>
After completion, create `.planning/phases/01-logger-foundation/01-02-SUMMARY.md`
</output>
